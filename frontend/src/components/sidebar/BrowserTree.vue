<script setup>
import { computed, h, nextTick, onMounted, reactive, ref } from 'vue'
import { ConnectionType } from '@/consts/connection_type.js'
import { NIcon, NSpace, NTag, useDialog, useMessage } from 'naive-ui'
import Key from '@/components/icons/Key.vue'
import ToggleDb from '@/components/icons/ToggleDb.vue'
import { find, get, includes, indexOf, isEmpty, remove } from 'lodash'
import { useI18n } from 'vue-i18n'
import Refresh from '@/components/icons/Refresh.vue'
import CopyLink from '@/components/icons/CopyLink.vue'
import Add from '@/components/icons/Add.vue'
import Layer from '@/components/icons/Layer.vue'
import Delete from '@/components/icons/Delete.vue'
import Connect from '@/components/icons/Connect.vue'
import useDialogStore from 'stores/dialog.js'
import { ClipboardSetText } from 'wailsjs/runtime/runtime.js'
import useConnectionStore from 'stores/connections.js'
import { useConfirmDialog } from '@/utils/confirm_dialog.js'
import ToggleServer from '@/components/icons/ToggleServer.vue'
import Unlink from '@/components/icons/Unlink.vue'
import Filter from '@/components/icons/Filter.vue'
import Close from '@/components/icons/Close.vue'
import { typesBgColor, typesColor } from '@/consts/support_redis_type.js'
import useTabStore from 'stores/tab.js'
import IconButton from '@/components/common/IconButton.vue'

const props = defineProps({
    server: String,
})

const i18n = useI18n()
const loading = ref(false)
const loadingConnections = ref(false)
const expandedKeys = ref([props.server])
const connectionStore = useConnectionStore()
const tabStore = useTabStore()
const dialogStore = useDialogStore()

/**
 *
 * @type {ComputedRef<string[]>}
 */
const selectedKeys = computed(() => {
    const tab = find(tabStore.tabList, { name: props.server })
    if (tab != null) {
        return get(tab, 'selectedKeys', [props.server])
    }
    return [props.server]
})

const data = computed(() => {
    const dbs = get(connectionStore.databases, props.server, [])
    return [
        {
            key: `${props.server}`,
            label: props.server,
            type: ConnectionType.Server,
            children: dbs,
        },
    ]
})

const backgroundColor = computed(() => {
    const { markColor: hex = '' } = connectionStore.serverProfile[props.server] || {}
    if (isEmpty(hex)) {
        return ''
    }
    const bigint = parseInt(hex.slice(1), 16)
    const r = (bigint >> 16) & 255
    const g = (bigint >> 8) & 255
    const b = bigint & 255
    return `rgba(${r}, ${g}, ${b}, 0.2)`
})

const contextMenuParam = reactive({
    show: false,
    x: 0,
    y: 0,
    options: null,
})
const renderIcon = (icon) => {
    return () => {
        return h(NIcon, null, {
            default: () => h(icon),
        })
    }
}
const menuOptions = {
    [ConnectionType.Server]: () => {
        return [
            {
                key: 'server_reload',
                label: i18n.t('reload'),
                icon: renderIcon(Refresh),
            },
            {
                key: 'server_close',
                label: i18n.t('disconnect'),
                icon: renderIcon(Unlink),
            },
        ]
    },
    [ConnectionType.RedisDB]: ({ opened }) => {
        if (opened) {
            return [
                {
                    key: 'db_reload',
                    label: i18n.t('reload'),
                    icon: renderIcon(Refresh),
                },
                {
                    key: 'db_newkey',
                    label: i18n.t('new_key'),
                    icon: renderIcon(Add),
                },
                {
                    key: 'db_filter',
                    label: i18n.t('filter_key'),
                    icon: renderIcon(Filter),
                },
                {
                    type: 'divider',
                    key: 'd1',
                },
                {
                    key: 'key_remove',
                    label: i18n.t('batch_delete'),
                    icon: renderIcon(Delete),
                },
                {
                    type: 'divider',
                    key: 'd2',
                },
                {
                    key: 'db_close',
                    label: i18n.t('close_db'),
                    icon: renderIcon(Close),
                },
            ]
        } else {
            return [
                {
                    key: 'db_open',
                    label: i18n.t('open_db'),
                    icon: renderIcon(Connect),
                },
            ]
        }
    },
    [ConnectionType.RedisKey]: () => [
        {
            key: 'key_reload',
            label: i18n.t('reload'),
            icon: renderIcon(Refresh),
        },
        {
            key: 'key_newkey',
            label: i18n.t('new_key'),
            icon: renderIcon(Add),
        },
        {
            key: 'key_copy',
            label: i18n.t('copy_path'),
            icon: renderIcon(CopyLink),
        },
        {
            type: 'divider',
            key: 'd1',
        },
        {
            key: 'key_remove',
            label: i18n.t('batch_delete'),
            icon: renderIcon(Delete),
        },
    ],
    [ConnectionType.RedisValue]: () => [
        {
            key: 'value_reload',
            label: i18n.t('reload'),
            icon: renderIcon(Refresh),
        },
        {
            key: 'value_copy',
            label: i18n.t('copy_key'),
            icon: renderIcon(CopyLink),
        },
        {
            type: 'divider',
            key: 'd1',
        },
        {
            key: 'value_remove',
            label: i18n.t('remove_key'),
            icon: renderIcon(Delete),
        },
    ],
}

const renderContextLabel = (option) => {
    return h('div', { class: 'context-menu-item' }, option.label)
}

onMounted(async () => {
    try {
        // TODO: Show loading list status
        loadingConnections.value = true
    } finally {
        loadingConnections.value = false
    }
})

const expandKey = (key) => {
    const idx = indexOf(expandedKeys.value, key)
    if (idx === -1) {
        expandedKeys.value.push(key)
    } else {
        expandedKeys.value.splice(idx, 1)
    }
}

const message = useMessage()
const dialog = useDialog()
const onUpdateExpanded = (value, option, meta) => {
    expandedKeys.value = value
    if (!meta.node) {
        return
    }
    // console.log(JSON.stringify(meta))
    switch (meta.action) {
        case 'expand':
            meta.node.expanded = true
            break
        case 'collapse':
            meta.node.expanded = false
            break
    }
}

const onUpdateSelectedKeys = (keys, options) => {
    try {
        if (!isEmpty(options)) {
            // prevent load duplicate key
            for (const node of options) {
                if (node.type === ConnectionType.RedisValue) {
                    const { key, db, redisKey } = node
                    if (!includes(selectedKeys.value, key)) {
                        connectionStore.loadKeyValue(props.server, db, redisKey)
                    }
                    return
                }
            }

            // default is load blank key to display server status
            connectionStore.loadKeyValue(props.server, 0)
        }
    } finally {
        tabStore.setSelectedKeys(props.server, keys)
    }
}

const renderPrefix = ({ option }) => {
    switch (option.type) {
        case ConnectionType.Server:
            return h(
                NIcon,
                { size: 20 },
                {
                    default: () => h(ToggleServer, { modelValue: false }),
                },
            )
        case ConnectionType.RedisDB:
            return h(
                NIcon,
                { size: 20 },
                {
                    default: () => h(ToggleDb, { modelValue: option.opened === true }),
                },
            )
        case ConnectionType.RedisKey:
            return h(
                NIcon,
                { size: 20 },
                {
                    default: () => h(Layer),
                },
            )
        case ConnectionType.RedisValue:
            return h(
                NIcon,
                { size: 20 },
                {
                    default: () => h(Key),
                },
            )
    }
}

// render tree item label
const renderLabel = ({ option }) => {
    switch (option.type) {
        case ConnectionType.RedisDB:
            const { name: server, db } = option
            let { match: matchPattern, type: typeFilter } = connectionStore.getKeyFilter(server, db)
            const items = [`${option.label} (${option.keys || 0})`]
            // show filter tag after label
            // type filter tag
            if (!isEmpty(typeFilter)) {
                items.push(
                    h(
                        NTag,
                        {
                            size: 'small',
                            closable: true,
                            bordered: false,
                            color: {
                                color: typesBgColor[typeFilter],
                                textColor: typesColor[typeFilter],
                            },
                            onClose: () => {
                                // remove type filter
                                connectionStore.setKeyFilter(server, db, matchPattern)
                                connectionStore.reopenDatabase(server, db)
                            },
                        },
                        { default: () => typeFilter },
                    ),
                )
            }
            // match pattern tag
            if (!isEmpty(matchPattern) && matchPattern !== '*') {
                items.push(
                    h(
                        NTag,
                        {
                            bordered: false,
                            closable: true,
                            size: 'small',
                            onClose: () => {
                                // remove key match pattern
                                connectionStore.setKeyFilter(server, db, '*', typeFilter)
                                connectionStore.reopenDatabase(server, db)
                            },
                        },
                        { default: () => matchPattern },
                    ),
                )
            }
            return renderIconMenu(items)
        case ConnectionType.RedisKey:
            return `${option.label} (${option.keys || 0})`
        // case ConnectionType.RedisValue:
        //   return `[${option.keyType}]${option.label}`
    }
    return option.label
}

// render horizontal item
const renderIconMenu = (items) => {
    return h(
        NSpace,
        {
            align: 'center',
            inline: true,
            size: 2,
            wrapItem: false,
            wrap: false,
            style: 'margin-right: 5px',
        },
        () => items,
    )
}

const getDatabaseMenu = (opened) => {
    const btns = []
    if (opened) {
        btns.push(
            h(IconButton, {
                tTooltip: 'filter_key',
                icon: Filter,
                onClick: () => handleSelectContextMenu('db_filter'),
            }),
            h(IconButton, {
                tTooltip: 'reload',
                icon: Refresh,
                onClick: () => handleSelectContextMenu('db_reload'),
            }),
            h(IconButton, {
                tTooltip: 'new_key',
                icon: Add,
                onClick: () => handleSelectContextMenu('db_newkey'),
            }),
            h(IconButton, {
                tTooltip: 'batch_delete',
                icon: Delete,
                onClick: () => handleSelectContextMenu('key_remove'),
            }),
        )
    } else {
        btns.push(
            h(IconButton, {
                tTooltip: 'open_db',
                icon: Connect,
                onClick: () => handleSelectContextMenu('db_open'),
            }),
        )
    }
    return btns
}

const getLayerMenu = () => {
    return [
        h(IconButton, {
            tTooltip: 'reload',
            icon: Refresh,
            onClick: () => handleSelectContextMenu('key_reload'),
        }),
        h(IconButton, {
            tTooltip: 'new_key',
            icon: Add,
            onClick: () => handleSelectContextMenu('key_newkey'),
        }),
        h(IconButton, {
            tTooltip: 'batch_delete',
            icon: Delete,
            onClick: () => handleSelectContextMenu('key_remove'),
        }),
    ]
}

const getValueMenu = () => {
    return [
        h(IconButton, {
            tTooltip: 'remove_key',
            icon: Delete,
            onClick: () => handleSelectContextMenu('value_remove'),
        }),
    ]
}

// render menu function icon
const renderSuffix = ({ option }) => {
    if (includes(selectedKeys.value, option.key)) {
        switch (option.type) {
            case ConnectionType.RedisDB:
                return renderIconMenu(getDatabaseMenu(option.opened))
            case ConnectionType.RedisKey:
                return renderIconMenu(getLayerMenu())
            case ConnectionType.RedisValue:
                return renderIconMenu(getValueMenu())
        }
    }
    return null
}

const nodeProps = ({ option }) => {
    return {
        onDblclick: () => {
            if (loading.value) {
                console.warn('TODO: alert to ignore double click when loading')
                return
            }
            // default handle is expand current node
            nextTick().then(() => expandKey(option.key))
        },
        onContextmenu(e) {
            e.preventDefault()
            if (!menuOptions.hasOwnProperty(option.type)) {
                return
            }
            contextMenuParam.show = false
            contextMenuParam.options = menuOptions[option.type](option)
            nextTick().then(() => {
                contextMenuParam.x = e.clientX
                contextMenuParam.y = e.clientY
                contextMenuParam.show = true
                tabStore.setSelectedKeys(props.server, option.key)
            })
        },
        // onMouseover() {
        //   console.log('mouse over')
        // }
    }
}

const onLoadTree = async (node) => {
    switch (node.type) {
        case ConnectionType.RedisDB:
            loading.value = true
            try {
                await connectionStore.openDatabase(props.server, node.db)
            } catch (e) {
                message.error(e.message)
                node.isLeaf = undefined
            } finally {
                loading.value = false
            }
            break
        // case ConnectionType.RedisKey:
        //     console.warn('load redis key', node.redisKey)
        //     node.keys = sumBy(node.children, 'keys')
        //     break
        // case ConnectionType.RedisValue:
        //     node.keys = 1
        //     break
    }
}

const confirmDialog = useConfirmDialog()
const handleSelectContextMenu = (key) => {
    contextMenuParam.show = false
    const selectedKey = get(selectedKeys.value, 0)
    if (selectedKey == null) {
        return
    }
    const node = connectionStore.getNode(selectedKey)
    const { db, key: nodeKey, redisKey } = node || {}
    switch (key) {
        case 'server_reload':
            connectionStore.openConnection(props.server, true).then(() => {
                message.success(i18n.t('reload_succ'))
            })
            break
        case 'server_close':
            connectionStore.closeConnection(props.server)
            break
        case 'db_open':
            nextTick().then(() => expandKey(nodeKey))
            break
        case 'db_reload':
            connectionStore.reopenDatabase(props.server, db)
            break
        case 'db_close':
            remove(expandedKeys.value, (k) => k === `${props.server}/db${db}`)
            connectionStore.closeDatabase(props.server, db)
            break
        case 'db_newkey':
        case 'key_newkey':
            dialogStore.openNewKeyDialog(redisKey, props.server, db)
            break
        case 'db_filter':
            const { match: pattern, type } = connectionStore.getKeyFilter(props.server, db)
            dialogStore.openKeyFilterDialog(props.server, db, pattern, type)
            break
        case 'key_reload':
            connectionStore.loadKeys(props.server, db, redisKey)
            break
        case 'value_reload':
            connectionStore.loadKeyValue(props.server, db, redisKey)
            break
        case 'key_remove':
            dialogStore.openDeleteKeyDialog(props.server, db, isEmpty(redisKey) ? '*' : redisKey + ':*')
            break
        case 'value_remove':
            confirmDialog.warning(i18n.t('remove_tip', { name: redisKey }), () => {
                connectionStore.deleteKey(props.server, db, redisKey).then((success) => {
                    if (success) {
                        message.success(i18n.t('delete_key_succ', { key: redisKey }))
                    }
                })
            })
            break
        case 'key_copy':
        case 'value_copy':
            ClipboardSetText(redisKey)
                .then((succ) => {
                    if (succ) {
                        message.success(i18n.t('copy_succ'))
                    }
                })
                .catch((e) => {
                    message.error(e.message)
                })
            break
        default:
            console.warn('TODO: handle context menu:' + key)
    }
}

const handleOutsideContextMenu = () => {
    contextMenuParam.show = false
}
</script>

<template>
    <div class="browser-tree-wrapper" :style="{ backgroundColor }">
        <n-tree
            :block-line="true"
            :block-node="true"
            :animated="false"
            :cancelable="false"
            :data="data"
            :expand-on-click="false"
            :expanded-keys="expandedKeys"
            :selected-keys="selectedKeys"
            @update:selected-keys="onUpdateSelectedKeys"
            :node-props="nodeProps"
            @load="onLoadTree"
            @update:expanded-keys="onUpdateExpanded"
            :render-label="renderLabel"
            :render-prefix="renderPrefix"
            :render-suffix="renderSuffix"
            class="fill-height"
            virtual-scroll
        />
        <n-dropdown
            :animated="false"
            :options="contextMenuParam.options"
            :render-label="renderContextLabel"
            :show="contextMenuParam.show"
            :x="contextMenuParam.x"
            :y="contextMenuParam.y"
            placement="bottom-start"
            trigger="manual"
            @clickoutside="handleOutsideContextMenu"
            @select="handleSelectContextMenu"
        />
    </div>
</template>

<style lang="scss" scoped>
.browser-tree-wrapper {
    height: 100%;
    overflow: hidden;
}
</style>
